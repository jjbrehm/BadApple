# R Script to implement the Imitation model from WSS
# - Aim is to use base R functions and avoid APL/C/Java code that
#   was probably inaccessible to many people
# - Thought was also that APL is in many ways a precursor to R, so
#   that the migration should not be hard

# bigloop1a takes as input just the number of trials
# # I *must* have been relying on a lot of globals
numburs <- 10
maxiter <- 10

bigloop1a <- function(trials) {
  # This routine randomly draws the assorted parameters
  # and stores the final mean supoutc as a dependent var
  # Version 1a calls policy 1a (relative punishment) based on punrate
  #ct <- 1                                                                ## unnecessary? see line below "loop"
  # Build a big matrix (x) of results per trial
  x <- array(data=rep(trials*17,0), dim=c(trials, 17))                    ## x seems to be a global? 
  # Loop starts here ("go")
  for (ct in 1:trials) {
    respparms <- runif(2)
    # respin <- mnandsd respparms                                         ## ??
    # draw supobsparms randomly for policy 1a/1b/2a/2b
    supobsparms <- runif(2)
    # uncomment for policy 1c/2c
    # subobsparms <- c(1, 0)
    burobsparms <- runif(2)
    # observability matrix (for bureaucrats) dist'd unif(0,1)
    # symmetric (x sees y sees x equally), where each entry is
    # probability of seeing
    # (obsty has to be global for the connectivity check)
    obsty <- array(runif(numburs^2),dim=c(numburs,numburs))               ## seems like numburs must be global??
    obsty[lower.tri(obsty)] <- t(obsty)[lower.tri(obsty)]
    diag(obsty) <- 1
    # supervisor observability (see and be seen, here) dist'd unif(0,1)   ## I say unif in the code, but seems norm??
    supobsty <- crop(rnorm(numburs, mean=supobsparms[1], sd=supobsparms[2]))
    # Set the range of desirability (why did I call it popparms??)        ## NOT IN ORIGINAL CODE
    popparms <- c(runif(1, min=-1, max=1), runif(1))
    # punrate is for policy1a/2a
    punrate <- runif(1, min=-2, max=0)
    # std is for policy 1b/1c/2b/2c
    std <- runif(1)
    punconst <- runif(1, min=0, max=2)
    # change call below to switch policy variation
    policy1a(popparms)
    mincontvyin <- analyze(obsty)                                         ## wouldn't seem that obsty has to be global
    x[ct, 1:10] <- c(supoutc[maxiter,], popparms, respparms, supobsparms, burobsparms)
    # will need to change punrate in line below to std for 1b/1c/2b/2c
    x[ct, 11:15] <- c(punrate, punconst, mincontvyin, mean(response), sd(response)) 
    x[ct, 16, 17] <- c(mean(buroutc[maxiter,]), sd(buroutc[maxiter,]))
  }
  x
}

policy1a <- function(mnpop) {
  # this version of the policy routine
  # assigns outcomes on the basis of dowhat * response
  # unless the saboteur is caught
  #
  #
  # get initial conditons
  # burs respond over -1 to 1, dist'd normally
  response <- -1 + 2*crop(rnorm(numburs, mean=respparms[1], sd=respparms[2]))
  # set counters to one, open result matrices
  iter <- 1
  catch <- 0
  didwhat <- buroutc <- array(0, dim=c(maxiter, numburs))
  supoutc <- array(0, dim=c(maxiter, 2))
  #getpolicy(mnpop)                                                       ## divergence!!! scope prevents this from working
  desire <- rnorm(numburs, mean=popparms[1], sd=popparms[2])
  
  # play: go from here
  for (iter in 1:maxiter) {
    # dowhat ranges from -1 (complete defection) to 1 (complete compliance)
    do <- response
    # outcome equals desires times do
    buroutc[iter,] <- desire*do
    # supervisor enforces against those she sees defecting
    supoutc[iter,] <- c(mean(do), sd(do))
    s <- trunc(supobsty+runif(1))
    # literal line 22 of policy1a
    #PUZZLE c{( ((punrateXsupoutc[iter;2]) > (do-supoutc[iter;1])) Xs)/Inumburs    ## PUZZLE THIS OUT LATER
    c <- which(as.logical((((punrate*supoutc[iter,2]) > (do-superoutc[iter,1]))*s))) # does this work?
    # L{c(((punrateXsupoutc[iter;2])>do-supoutc[iter;1])Xs/Inumbers                 ## leave this commented??
    if(length(c)!=0) {
      # C}(0=Rc{((punrateXsupoutc[iter;2])>do-supoutc[iter;1])Xs/Inumburs/adapt    # I *think* they fall through
      catch <- catch + 1
      buroutc[iter,c] <- buroutc[iter,c] - punconst
    }
    # adapt:
    #PUZZLE seenoutc{((2Rnumburs)Rburoutc[iter;])Xobsty
    seenoutc <- array(data=buroutc[iter,], dim=c(numburs,numburs)) %*% obsty        # does this work?
    # choose response of the person you saw who did best
    #PUZZLE envy{S/(seenoutc=\<bs>O(2Rnumburs)R(S/seenoutc))X(2Rnumburs)RInumburs
    envy <- which(max(seenoutc))                                                    # does this work?
    response <- do[envy]
    # update didwahat (uncomment if you have didwhat set)
    didwhat[iter,] <- do
    # play again, unless this iteration exceeds maxiter
  }
}

# 'normal' should not be necessary given built-in distribution functions

# mnandsd probably isn't necessary
mnandsd <- function(str) {
  c(mean(str), sd(str))
}

# getpolicy
getpolicy <- function(mnpop) {
  # fn returns vector of desirability to burs (dist'd norm)
  desire <- rnorm(numburs, mean=mnpop[1], sd=mnpop[2])
}

# analyze finds the connectivity of the matrix
# are there other sources??

# crop
crop <- function(y) {
  y[y>1] <- 1
  y[y<0] <- 0
}
